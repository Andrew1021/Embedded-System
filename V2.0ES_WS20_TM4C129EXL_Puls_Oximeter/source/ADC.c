/*
 * ADC.c
 *
 *  Created on: 20.12.2020
 *      Author: Andreas Roth, Kevin Schultz, Sebastian Hofmaier
 */
#include <stdbool.h>
#include <stdint.h>
#include "inc/hw_memmap.h"
#include "driverlib/adc.h"
#include "driverlib/interrupt.h"
#include "driverlib/gpio.h"
#include "driverlib/pin_map.h"
#include "driverlib/sysctl.h"
#include "../header/ADC.h"

// The system clock speed.
extern uint32_t g_ui32SysClock;

static const adc_t adcInfo[ADC_ID_MAX + 1] =
        {
             {SYSCTL_PERIPH_ADC0, ADC0_BASE, false, ADC_CTL_CH0, ADC_CTL_IE, ADC_CTL_END, GPIO_PIN_2, 3, ADC_TRIGGER_PROCESSOR},  // ADC_ID_ADC0
             {SYSCTL_PERIPH_ADC1, ADC1_BASE, false, ADC_CTL_CH1, ADC_CTL_IE, ADC_CTL_END, GPIO_PIN_3, 3, ADC_TRIGGER_PROCESSOR},  // ADC_ID_ADC1
        };



/** @brief Setup adc trigger conversion
* @param  adcID       : 0 : ADC0
*                     : 1 : ADC1
* @return  1: Success
*          0: Error
*/
int ADC_Init(uint8_t adc_id)
{
    if(adc_id <= ADC_ID_MAX)
    {
        // Enable ADC peripherals:
        // The ADC0 peripheral must be enabled for use.
        SysCtlPeripheralEnable(adcInfo[adc_id].peripheral_id);

        // For this example ADC0 is used with AIN0/1 on port E3/E2.
        // The actual port and pins used may be different on your part, consult
        // the data sheet for more information.  GPIO port E needs to be enabled
        // so these pins can be used.
        if (!SysCtlPeripheralReady(SYSCTL_PERIPH_GPIOE))
        {
            SysCtlPeripheralEnable(SYSCTL_PERIPH_GPIOE);
        }

        // Check if the peripheral access is enabled. (Wait for PWMx module to become ready)
        while(!(SysCtlPeripheralReady(adcInfo[adc_id].peripheral_id) && SysCtlPeripheralReady(SYSCTL_PERIPH_GPIOE))){}

        // Select the analog ADC function for these pins.
        // Consult the data sheet to see which functions are allocated per pin.
        GPIOPinTypeADC(GPIO_PORTE_BASE, adcInfo[adc_id].gpio_pin);

        // Sets the clock configuration for the ADC.
        // Must be between 16MHz and 32 MHz
        // 120 MHz / 6 = 20 MHz
        // Base:        ADC0_BASE or ADC1_BASE
        // Config:
        //          Available options:
        //              ADC_CLOCK_SRC_PLL       Main PLL output
        //              ADC_CLOCK_SRC_PIOSC     Internal PIOC at 16 MHz
        //              ADC_CLOCK_SRC_ALTCLK
        //              ADC_CLOCK_SRC_MOSC      external Osc
        //
        //              ADC_CLOCK_RATE_FULL     provide all samples to application
        //              ADC_CLOCK_RATE_HALF     provide every other sample to application
        //              ADC_CLOCK_RATE_QUARTER  provide every fourth sample to application
        //              ADC_CLOCK_RATE_EIGHTH   provide every eighth sample to application
        // ClockDiv:    1...64                  (clock divider)
        ADCClockConfigSet(adcInfo[adc_id].base_id, ADC_CLOCK_SRC_PLL | ADC_CLOCK_RATE_FULL, 6);

        // Activate Hardware oversampling
        // Base:        ADC0_BASE               (use ADC0)
        // Factor:      2,4,8,16,32,64          (number of samples to be averaged)
        ADCHardwareOversampleConfigure(ADC0_BASE, 8);

        // Configure sequence
        // ~~~~~~~~~~~~~~~~~~
        // Enable sample sequence 3 (single sample) with a processor signal trigger via ADCProcessorTrigger() function.
        // Base:        ADC0_BASE               (use ADC0)
        // SequenceNum: ADC_SEQUENCE            (Sequence 1, up to 4 samples)
        // Trigger:                             (ADC trigger)
        //          Available options:
        //              ADC_TRIGGER_PROCESSOR   A trigger generated by the processor, via the ADCProcessorTrigger() function.
        //              ADC_TRIGGER_TIMER       A trigger generated by a timer; configured with TimerControlTrigger().
        //              ADC_TRIGGER_COMP<n>     A trigger generated by the analog comparator n; configured with ComparatorConfigure().
        //              ADC_TRIGGER_PWM<n>      A trigger generated by the PWM generator n; configured with PWMGenIntTrigEnable().
        //              ADC_TRIGGER_ALWAYS      A trigger that is always asserted, causing the sample sequence to capture repeatedly (so long as there is not a higher priority source active).
        //          Used options:
        //              ADC_TRIGGER_TIMER       A  trigger generated by a timer; configured with TimerControlTrigger().
        // Priority:    0
        ADCSequenceConfigure(adcInfo[adc_id].base_id, adcInfo[adc_id].sequence, adcInfo[adc_id].adc_trigger, 0);

        // Configure Sequence steps
        // ~~~~~~~~~~~~~~~~~~~~~~~~~~
        // Sequence 0: 8 Steps
        // Sequence 1: 4 Steps
        // Sequence 2: 4 Steps
        // Sequence 3: 1 Step

        // Sequence 3 has 1 step
        // Configure step 0 on sequence ADC_SEQUENCE.
        // Base:        ADC0_BASE    (use ADC0/ADC1)
        // SequenceNum: ADC_SEQUENCE (3)
        // Step:        0
        // Config:                              (Configuration of this step)
        //          Available options:
        //              ADC_CTL_CH0...ADC_CTL_CH19, ADC_CH_TS   : Input Channel (AIN0..19 or TempSensor)
        //              ADC_CTL_D           Select Differential operation (instead of single ended)
        //              ADC_CTL_END:        This is the last step in the sequence
        //              ADC_CTL_IE:         Trigger Interrupt when the step is complete
        //              ADC_CTL_CMP0...ADC_CTL_CMP7.            : Send result to comparator n
        //          Used options:
        //              ADC_CTL_CH6:   Sample channel 6  (in single-ended mode (default))
        //              ADC_CTL_IE:     Set interrupt flag => Interrupt when the sample is done.
        //              ADC_CTL_END:    Tell the ADC logic that this is the last conversion on sequence 3

        // Configure step 0 on sequence 3.  Sample channel 0 (ADC_CTL_CH0) in
        // single-ended mode (default) and configure the interrupt flag
        // (ADC_CTL_IE) to be set when the sample is done.  Tell the ADC logic
        // that this is the last conversion on sequence 3 (ADC_CTL_END).  Sequence
        // 3 has only one programmable step.  Sequence 1 and 2 have 4 steps, and
        // sequence 0 has 8 programmable steps.  Since we are only doing a single
        // conversion using sequence 3 we will only configure step 0.  For more
        // information on the ADC sequences and steps, reference the datasheet.
        ADCSequenceStepConfigure(adcInfo[adc_id].base_id, adcInfo[adc_id].sequence, 0,
                                 adcInfo[adc_id].adc_ch_id |
                                 adcInfo[adc_id].adc_interupt_flag |
                                 adcInfo[adc_id].last_conversion_flag);

        return(1);  // success
    }
    else
    {
        return(0);  // Error
    }
}

/** @brief Enable adc trigger conversion
* @param  adcID       : 0 : ADC0
*                     : 1 : ADC1
* @return  1: Success
*          0: Error
*/
int ADC_Enable(uint8_t adc_id)
{
    if(adc_id <= ADC_ID_MAX)
    {
        // Since sample sequence 3 is now configured, it must be enabled.
        // Enable Sequence ADC_SEQUENCE
        ADCSequenceEnable(adcInfo[adc_id].base_id, adcInfo[adc_id].sequence);

        // Clear the interrupt status flag.  This is done to make sure the
        // interrupt flag is cleared before we sample.
        ADCIntClear(adcInfo[adc_id].base_id, adcInfo[adc_id].sequence);

        return(1);  // success
    }
    else
    {
        return(0);  // Error
    }
}

/** @brief Trigger adc conversion
* @param  adcID       : 0 : ADC0
*                     : 1 : ADC1
* @return  1: Success
*          0: Error
*/
uint32_t ADC_Trigger(uint8_t adc_id)
{
    if(adc_id <= ADC_ID_MAX)
    {
        // This array is used for storing the data read from the ADC FIFO. It
        // must be as large as the FIFO for the sequencer in use.  This example
        // uses sequence 3 which has a FIFO depth of 1.  If another sequence
        // was used with a deeper FIFO, then the array size must be changed.
        uint32_t pui32ADCValue[1];

        // Trigger the ADC conversion.
        ADCProcessorTrigger(adcInfo[adc_id].base_id, adcInfo[adc_id].sequence);

        // Wait for conversion to be completed.
        while(!ADCIntStatus(adcInfo[adc_id].base_id, adcInfo[adc_id].sequence, false)){}

        // Clear the ADC interrupt flag. To make sure the interrupt flag is cleared before we sample again.
        ADCIntClear(adcInfo[adc_id].base_id, adcInfo[adc_id].sequence);

        // Read ADC Value.
        ADCSequenceDataGet(adcInfo[adc_id].base_id, adcInfo[adc_id].sequence, pui32ADCValue);

        return (pui32ADCValue[0]); // success, return sample value
    }
    else
    {
        return(0);  // Error
    }
}

/** @brief Enable adc trigger conversion
* @param  adcID       : 0 : ADC0
*                     : 1 : ADC1
* @return  1: Success
*          0: Error
*/
int ADC_Disable(uint8_t adc_id)
{
    if(adc_id <= ADC_ID_MAX)
    {
        // disable ADC
        // sample sequence 3 is configured, it must be disabled.
        ADCSequenceDisable(adcInfo[adc_id].base_id, adcInfo[adc_id].sequence);

        // Clear the interrupt status flag.  This is done to make sure the
        // interrupt flag is cleared before we sample.
        ADCIntClear(adcInfo[adc_id].base_id, adcInfo[adc_id].sequence);

        return(1);  // success
    }
    else
    {
        return(0);  // Error
    }
}

/** @brief Stop adc and free resources connected to adc trigger conversion
* @param  adcID       : 0 : ADC0
*                     : 1 : ADC1
* @return  1: Success
*          0: Error
*/
int ADC_Close(uint8_t adc_id)
{
    if(adc_id <= ADC_ID_MAX)
    {
        ADC_Disable(adc_id);

        // Disable Interrupts
        ADCIntDisable(adcInfo[adc_id].base_id, adcInfo[adc_id].sequence);

        // enable peripheral again:
        // The PWM peripheral must be enabled for use.
        SysCtlPeripheralEnable(adcInfo[adc_id].peripheral_id);
        // Enable the GPIO port that is used for the ADC input.
        SysCtlPeripheralEnable(SYSCTL_PERIPH_GPIOE);

        // Check if the peripheral access is enabled. (Wait for ADCx module to become ready)
        while(!(SysCtlPeripheralReady(adcInfo[adc_id].peripheral_id) && SysCtlPeripheralReady(SYSCTL_PERIPH_GPIOE))){}

        return(1);  // success
    }
    else
    {
        return(0);  // Error
    }
}

/** @brief The interrupt handler for the for ADC0 interrupts
*/
void ADC0IntHandler(void)
    {
        // Clear the interrupt status flag.  This is done to make sure the
        // interrupt flag is cleared before we sample.
        ADCIntClear(ADC0_BASE, 3);
    }

/** @brief The interrupt handler for the for ADC0 interrupts
*/
void ADC1IntHandler(void)
    {
    // Clear the interrupt status flag.  This is done to make sure the
            // interrupt flag is cleared before we sample.
            ADCIntClear(ADC1_BASE, 3);
    }

/** @brief ADC_Modul test function - to be defined
* @param  adcID       : 0 : ADC0
*                     : 1 : ADC1
* @return  1: Success
*          0: Error
*/
int ADC_Test(uint8_t adc_id)
{
    if(adc_id <= ADC_ID_MAX)
    {
        // Setup ADC functionality for ADC0
        // Select: ADC_ID_ADC0 for ADC0 on Port E 3
        uint8_t status_init = ADC_Init(adc_id);

        // Enable processor interrupts.
        IntMasterEnable();

        // Enable ADC Sequence for single sample
        // Select: ADC_ID_ADC0 for ADC0 on Port E 3
        uint8_t status_enable = ADC_Enable(adc_id);

        // Trigger ADC conversion for single sample
        // Select: ADC_ID_ADC0 for ADC0 on Port E 3
        uint32_t sample = ADC_Trigger(adc_id);

        // Disable ADC Sequence for single sample and free hardware resources
        uint8_t status_close = ADC_Close(adc_id);

        return(1);  // success
    }
    else
    {
        return(0);  // Error
    }
}
